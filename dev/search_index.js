var documenterSearchIndex = {"docs":
[{"location":"man/objects/#SymPh.Maths.Form","page":"-","title":"SymPh.Maths.Form","text":"Form{D,P<:Primality}\n\nArguments\n\nD::Integer : degree (0/1/2... form)\nP::Primality : The primality of the form\n\n\n\n\n\n","category":"type"},{"location":"man/objects/#SymPh.Maths.Vect","page":"-","title":"SymPh.Maths.Vect","text":"VectorVariable\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"SymPh is a module","category":"page"},{"location":"man/equation/#Defining-our-equation","page":"Building an equation","title":"Defining our equation","text":"","category":"section"},{"location":"man/equation/#The-maths","page":"Building an equation","title":"The maths","text":"","category":"section"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We will us as an example the stream function-vorticity formulation of the Euler equations with the vorticity omega as our prognostic variable. ","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"This gives us ","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"partial_t omega = mathcalL_U omega = mathrmd(iota_U omega)","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"with ","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"begincases\n    nabla^2 omega^2 = Psi^2 \n    u^1 = delta Psi \n    U = u^sharp\nendcases","category":"page"},{"location":"man/equation/#Representing-it","page":"Building an equation","title":"Representing it","text":"","category":"section"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We use the @Let macro to avoid having to specify the name of each object we define. It will use the variable name as the object name.","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We start by defining our prognostic variable :","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"@Let omega = FormVariable{2, Dual}()","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"Then we define the rest of the variables in relation to already defined variables :","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"@Let psi = InverseLaplacian(omega)\n@Let u = Codifferential(psi)\n@Let U = Sharp(u)\n\n#Time derivative\n@Let dtomega = - ExteriorDerivative(InteriorProduct(U, omega)) #dtω = L(U,ω)","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"For now (if we want to use the time integrator from SymPh) the time derivative of prognostics variables must have the same name as the variable with dt at the beginning.","category":"page"},{"location":"man/equation/#Specifying-the-numerical-methods","page":"Building an equation","title":"Specifying the numerical methods","text":"","category":"section"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We then build an ExplicitParam object, specifying for example the interpolation method used for the interior product.","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"explparams = ExplicitParam(; interp = Arrays.weno)","category":"page"},{"location":"man/equation/#Building-the-kernel-function","page":"Building an equation","title":"Building the kernel function","text":"","category":"section"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We can now use those objects to finally generate the function that will perform our computations.","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"euler_rhs! = to_kernel(dtomega; save = [\"u_x\", \"u_y\", \"ι_U_omega_x\", \"ι_U_omega_y\"], explparams = explparams)","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We have to pass the objects that we want to be computed, for example in the case of a time integration, our time derivative, as well as a list of intermediary values that we want saved and our numerical methods.","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"## Building the mesh","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We then define the parameters of a mesh, notably its size and a mask of its fluid cells","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"nx = 100\nny = 100\nnh = 3\n\nmsk = zeros(nx, ny)\nmsk[nh+1:nx-nh, nh+1:ny-nh] .= 1\n\nLx, Ly = (1,1)","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We also have to choose a loop manager to run the program","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"scalar = PlainCPU()\nsimd = VectorizedCPU(16)\nthreads = MultiThread(scalar)","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"And we can finally build our mesh object","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"mesh = Arrays.Mesh(nx, ny, nh, thsimd, msk, Lx, Ly)","category":"page"},{"location":"man/equation/#Defining-the-state-and-initial-conditions","page":"Building an equation","title":"Defining the state and initial conditions","text":"","category":"section"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We initialize a State object, that will automatically allocate the arrays we ask it to give us, if they are not already initialized","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"state = State(mesh)","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"and we fill our omega with an initial condition, for example a vortex merging experiment :","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"gaussian(x,y,x0,y0,sigma) = exp(-((x-x0)^2 + (y-y0)^2)/(2*sigma^2))\ndipole(x,y,x0,y0,d,sigma) = gaussian(x, y, x0+d/2, y0, sigma) + gaussian(x, y, x0-d/2, y0, sigma)\n\nomega = state.omega\nfor i in nh+1:nx-nh, j in nh+1:ny-nh\n\tx = mesh.xc[i,j]\n\ty = mesh.yc[i,j]\n\tomega[i,j] = tripole(x, y, 0.5,0.5,0.3,0.05) * mesh.msk2d[i,j]\nend","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We can now finally create the integration model that will hold all of this, by also specifying our prognostic variable and an integrator.","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"model = Model(euler_rhs!, mesh, state, [\"omega\"]; cfl = 100., dtmax = 5., integratorstep! = rk3step!)","category":"page"},{"location":"man/equation/#Running-the-simulation","page":"Building an equation","title":"Running the simulation","text":"","category":"section"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We can now run our model for a certain time, and choose which variables should be written to disk or plotted.","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"run!(model; save_every = 5, plot = false, plot_var=state.omega, profiling = false, tend = 10000, maxite = 100, writevars = (:u_x, :u_y, :omega, :psi))","category":"page"},{"location":"man/operators/#SymPh.Maths.Addition","page":"Differential Geometry Operators","title":"SymPh.Maths.Addition","text":"Addition{D,P}(name::String, left::Form{D,P}, right::Form{D,P}) <: Form{D,P}\n\nThe element-wise sum left + right.\n\n\n\n\n\n","category":"type"},{"location":"man/operators/#SymPh.Maths.Substraction","page":"Differential Geometry Operators","title":"SymPh.Maths.Substraction","text":"Substraction{D,P}(name::String, left::Form{D,P}, right::Form{D,P}) <: Form{D,P}\n\nThe substraction left - right.\n\n\n\n\n\n","category":"type"},{"location":"man/operators/#SymPh.Maths.Negative","page":"Differential Geometry Operators","title":"SymPh.Maths.Negative","text":"Negative{D,P}(name::String, form::Form{D,P}) <: Form{D,P}\n\nThe inverse of a form.\n\n\n\n\n\n","category":"type"},{"location":"man/operators/#SymPh.Maths.FuncCall","page":"Differential Geometry Operators","title":"SymPh.Maths.FuncCall","text":"FuncCall{D, P}(name::String, func, args::Vector{Form}) <: Form{D,P}\n\nRepresents a call to func applied to the objects represented by args. Forces the computation of its arguments.\n\n\n\n\n\n","category":"type"},{"location":"man/operators/#SymPh.Maths.Division","page":"Differential Geometry Operators","title":"SymPh.Maths.Division","text":"Division{D,P}(name::String, left::Form{D,P}, right::Form) <: Form{D,P}\n\nTODO What is that actually in terms of FORMS ? Simple division by a scalar field proxied by a 0-form ?\n\n\n\n\n\n","category":"type"},{"location":"man/operators/#SymPh.Maths.ExteriorDerivative","page":"Differential Geometry Operators","title":"SymPh.Maths.ExteriorDerivative","text":"ExteriorDerivative{D,P}(name::String, omega::Form{D-1,P}) <: Form{D,P}\n\nThe exterior derivative mathrmdomega\n\nTransforms a k-form into a k+1-form\n\n\n\n\n\n","category":"type"},{"location":"man/operators/#SymPh.Maths.Codifferential","page":"Differential Geometry Operators","title":"SymPh.Maths.Codifferential","text":"Codifferential{D,P}(name::String, omega::Form{D+1,P}) <: Form{D,P}\n\nThe codifferential delta omega\n\nTransforms a k-form into a k-1-form\n\n\n\n\n\n","category":"type"},{"location":"man/operators/#SymPh.Maths.InteriorProduct","page":"Differential Geometry Operators","title":"SymPh.Maths.InteriorProduct","text":"InteriorProduct{D, Pv, Pf}(name::String, X::Vect, omega::Form, interp = Nothing) <: Form{D, Pf}\n\nThe contraction of a k-form omega with a vector field mathbfX which gives us a k-1-form iota_mathbfXomega Possibility to specify interpolation function\n\n\n\n\n\n","category":"type"},{"location":"man/operators/#SymPh.Maths.Sharp","page":"Differential Geometry Operators","title":"SymPh.Maths.Sharp","text":"Sharp\n\n\n\n\n\n","category":"type"},{"location":"man/operators/#SymPh.Maths.Hodge","page":"Differential Geometry Operators","title":"SymPh.Maths.Hodge","text":"Hodge\n\n\n\n\n\n","category":"type"},{"location":"man/operators/#SymPh.Maths.InnerProduct","page":"Differential Geometry Operators","title":"SymPh.Maths.InnerProduct","text":"InnerProduct\n\n\n\n\n\n","category":"type"},{"location":"man/operators/#SymPh.Maths.RealProdForm","page":"Differential Geometry Operators","title":"SymPh.Maths.RealProdForm","text":"RealProducts\n\n\n\n\n\n","category":"type"},{"location":"man/operators/#SymPh.Maths.InverseLaplacian","page":"Differential Geometry Operators","title":"SymPh.Maths.InverseLaplacian","text":"InverseLaplacian\n\nRepresents the solution to a Poisson problem\n\n\n\n\n\n","category":"type"}]
}

var documenterSearchIndex = {"docs":
[{"location":"ref/arrays/#Arrays","page":"Arrays","title":"Arrays","text":"","category":"section"},{"location":"ref/arrays/#Objects-and-Variables","page":"Arrays","title":"Objects and Variables","text":"","category":"section"},{"location":"ref/arrays/#Abstract-types","page":"Arrays","title":"Abstract types","text":"","category":"section"},{"location":"ref/arrays/#Concrete-types","page":"Arrays","title":"Concrete types","text":"","category":"section"},{"location":"ref/arrays/#Operations-on-arrays","page":"Arrays","title":"Operations on arrays","text":"","category":"section"},{"location":"ref/arrays/#Meshes","page":"Arrays","title":"Meshes","text":"","category":"section"},{"location":"ref/arrays/#Interpolations","page":"Arrays","title":"Interpolations","text":"","category":"section"},{"location":"ref/arrays/#Finite-volumes-and-finite-differences","page":"Arrays","title":"Finite volumes and finite differences","text":"","category":"section"},{"location":"ref/arrays/#From-arrays-to-kernels","page":"Arrays","title":"From arrays to kernels","text":"","category":"section"},{"location":"ref/arrays/#SymPh.Arrays","page":"Arrays","title":"SymPh.Arrays","text":"Arrays\n\nA module containing symbolic representations of arrays, and operations on them, and a way to convert them to computational kernels\n\n\n\n\n\n","category":"module"},{"location":"ref/arrays/#SymPh.Arrays.Expression","page":"Arrays","title":"SymPh.Arrays.Expression","text":"Expression\n\nGeneric Expression\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Atom","page":"Arrays","title":"SymPh.Arrays.Atom","text":"Atom <: Expression\n\nAn atom is a singular element holding a value (Variable or not)\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Literal","page":"Arrays","title":"SymPh.Arrays.Literal","text":"Literal <: Atom\n\nLiteral constant value\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Variable","page":"Arrays","title":"SymPh.Arrays.Variable","text":"Variable <: Atom\n\nAny variable value\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.RealValue","page":"Arrays","title":"SymPh.Arrays.RealValue","text":"RealValue(name::String, val::Real) <: Literal\n\nA constant real value\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.ScalarVariable","page":"Arrays","title":"SymPh.Arrays.ScalarVariable","text":"ScalarVariable(name::String) <: Variable\n\nA variable holding a single scalar value\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.ArrayVariable","page":"Arrays","title":"SymPh.Arrays.ArrayVariable","text":"ArrayVariable(name::String, depi::Integer, depj::Integer) <: Variable\n\nArray object representing a variable name and a relative position\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Operator","page":"Arrays","title":"SymPh.Arrays.Operator","text":"Operator <: Expression\n\nGeneric operation on an expression\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.FuncCall","page":"Arrays","title":"SymPh.Arrays.FuncCall","text":"FuncCall(name::String, func, args::Vector{Expression}, depi::Integer, depj::Integer) <: Operator\n\nForces computation of its arguments, then calls a function on them For now the function must have signature f(out, args...) where out will be replaced by the name assigned to the operator\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.UnaryOperator","page":"Arrays","title":"SymPh.Arrays.UnaryOperator","text":"UnaryOperator\n\nAny operator of a single argument\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Negative","page":"Arrays","title":"SymPh.Arrays.Negative","text":"Negative\n\nRepresents the negation of an expression\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.AbsoluteValue","page":"Arrays","title":"SymPh.Arrays.AbsoluteValue","text":"AbsoluteValue\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.BinaryOperator","page":"Arrays","title":"SymPh.Arrays.BinaryOperator","text":"BinaryOperator\n\nAny operator on two expressions\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Addition","page":"Arrays","title":"SymPh.Arrays.Addition","text":"Addition\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Substraction","page":"Arrays","title":"SymPh.Arrays.Substraction","text":"Substraction\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Multiplication","page":"Arrays","title":"SymPh.Arrays.Multiplication","text":"Multiplication\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Division","page":"Arrays","title":"SymPh.Arrays.Division","text":"Division\n\nTODO error handling\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Exponentiation","page":"Arrays","title":"SymPh.Arrays.Exponentiation","text":"Exponentiation\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.BooleanExpression","page":"Arrays","title":"SymPh.Arrays.BooleanExpression","text":"BooleanExpression\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.UnaryBooleanOperator","page":"Arrays","title":"SymPh.Arrays.UnaryBooleanOperator","text":"UnaryBooleanOperator\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.BinaryBooleanOperator","page":"Arrays","title":"SymPh.Arrays.BinaryBooleanOperator","text":"BinaryBooleanOperator\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.TernaryOperator","page":"Arrays","title":"SymPh.Arrays.TernaryOperator","text":"TernaryOperator\n\nSymbolic representation of a ? b : c\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.GreaterThan","page":"Arrays","title":"SymPh.Arrays.GreaterThan","text":"GreaterThan\n\ntests if left > right\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Mesh","page":"Arrays","title":"SymPh.Arrays.Mesh","text":"Mesh(ni, nj, nh, mgr, msk, xc, yc, xv, yv; iperio=false, jperio=false)\n\nTODO document\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.CartesianMesh","page":"Arrays","title":"SymPh.Arrays.CartesianMesh","text":"CartesianMesh(ni, nj, nh, mgr, Lx = 1, Ly = 1; xperio=false, yperio=false)\n\nA rectangular mesh of extent Lx, Ly\n\n\n\n\n\n","category":"function"},{"location":"ref/arrays/#SymPh.Arrays.PolarMesh","page":"Arrays","title":"SymPh.Arrays.PolarMesh","text":"PolarMesh(ni, nj, nh, mgr, msk, rin = 0.5, rout = 1.5)\n\nAn annulus mesh with inner radius rin and outer radius rout\n\nThe i/x direction is the radial, j/y orthoradial\n\n\n\n\n\n","category":"function"},{"location":"ref/arrays/#SymPh.Arrays.upwind","page":"Arrays","title":"SymPh.Arrays.upwind","text":"upwind(U::Expression, a::Expression, o::Expression, lr::String, dir::String)\n\nFive point upwind interpolation\n\nArguments\n\nU : The transportant velocity\na : The object to upwind\no : The order of interpolation at that point\nlr : If lr==\"left\", compute a[i-0.5], else a[i+0.5]\ndir : along i or j\n\n\n\n\n\n","category":"function"},{"location":"ref/arrays/#SymPh.Arrays.avg2pt","page":"Arrays","title":"SymPh.Arrays.avg2pt","text":"avg2pt(U::Expression, a::Expression, o::Expression, lr::String, dir::String)\n\nTwo point average interpolation\n\nArguments\n\nU : The transportant velocity, unused\na : The object to interpolate\no : The order of interpolation at that point, unused\nlr : If lr==\"left\", compute a[i-0.5], else a[i+0.5]\ndir : along i or j\n\n\n\n\n\n","category":"function"},{"location":"ref/arrays/#SymPh.Arrays.weno","page":"Arrays","title":"SymPh.Arrays.weno","text":"weno(U::Expression, a::Expression, o::Expression, lr::String, dir::String)\n\nWeno interpolation of fifth order\n\nArguments\n\nU : The transportant velocity\na : The object to upwind\no : The order of interpolation at that point\nlr : If lr==\"left\", compute a[i-0.5], else a[i+0.5]\ndir : along i or j\n\n\n\n\n\n","category":"function"},{"location":"ref/arrays/#SymPh.Arrays.fvtofd2","page":"Arrays","title":"SymPh.Arrays.fvtofd2","text":"fvtofd2(q, msk, dir)\n\nA second order function to take a finite volume quantity q to finite difference in the direction dir, using msk to detect borders\n\n\n\n\n\n","category":"function"},{"location":"ref/arrays/#SymPh.Arrays.fvtofd4","page":"Arrays","title":"SymPh.Arrays.fvtofd4","text":"fvtofd4(q, msk, dir)\n\nA fourth order function to take a finite volume quantity q to finite difference in the direction dir, using msk to detect borders\n\n\n\n\n\n","category":"function"},{"location":"ref/arrays/#SymPh.Arrays.fdtofv2","page":"Arrays","title":"SymPh.Arrays.fdtofv2","text":"fdtofv2(q, msk, dir)\n\nA second order function to take a finite difference quantity q to finite volume in the direction dir, using msk to detect borders\n\n\n\n\n\n","category":"function"},{"location":"ref/arrays/#SymPh.Arrays.fdtofv4","page":"Arrays","title":"SymPh.Arrays.fdtofv4","text":"fdtofv4(q, msk, dir)\n\nA fourth order function to take a finite difference quantity q to finite volume in the direction dir, using msk to detect borders\n\n\n\n\n\n","category":"function"},{"location":"ref/arrays/#SymPh.Arrays.DepNode","page":"Arrays","title":"SymPh.Arrays.DepNode","text":"DepNode(name::String, expr::Union{Nothing, Expression})\n\nA node of a dependency tree of expressions made of expressions\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Block","page":"Arrays","title":"SymPh.Arrays.Block","text":"Block\n\nAny operation or block of operations that can be done at once\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.LoopBlock","page":"Arrays","title":"SymPh.Arrays.LoopBlock","text":"LoopBlock\n\nA block of operations to be computed in a loop on our domain\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.CallBlock","page":"Arrays","title":"SymPh.Arrays.CallBlock","text":"CallBlock\n\nA block representing a single function call\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Sequence","page":"Arrays","title":"SymPh.Arrays.Sequence","text":"Sequence\n\nA sequence of blocks of operations\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.to_kernel","page":"Arrays","title":"SymPh.Arrays.to_kernel","text":"to_kernel(seq::Sequence, fill; verbose = false)\n\nConverts seq into a computing kernel, fill is the list of names of value that need their halo filled.\n\n\n\n\n\n","category":"function"},{"location":"ref/maths/#Maths","page":"Maths","title":"Maths","text":"","category":"section"},{"location":"ref/maths/#Abstract-Objects","page":"Maths","title":"Abstract Objects","text":"These are abstract object representing differential forms and vectors","category":"section"},{"location":"ref/maths/#Variables","page":"Maths","title":"Variables","text":"The variables upon which we act with our operators. Typically our prognostic variables will be defined like this since they are not defined as an operation on something.","category":"section"},{"location":"ref/maths/#Operators","page":"Maths","title":"Operators","text":"These are the operators acting on our variables. Their type is the type of the result of the operation.","category":"section"},{"location":"ref/maths/#The-Wedge-product-\\wedge","page":"Maths","title":"The Wedge product wedge","text":"","category":"section"},{"location":"ref/maths/#The-Exterior-Derivative-\\mathrm{d}","page":"Maths","title":"The Exterior Derivative mathrmd","text":"The exterior derivative mathrmdomega of a k-form omega is a k+1-form.\n\nIn 2D, \n\nmathrmdF^0 = partial_x f mathrmd x+partial_y f mathrmd y\n\nCorresponds to the gradient operation on a scalar field.\n\nmathrmdU^1 = (partial_x u_2-partial_y u_1) mathrmd x wedge mathrmd y\n\nCorresponds to the curl of a vector field.\n\nmathrmd W^2 = 0","category":"section"},{"location":"ref/maths/#The-Codifferential-\\delta","page":"Maths","title":"The Codifferential delta","text":"","category":"section"},{"location":"ref/maths/#The-Interior-Product-with-a-vector-field-\\iota_\\mathbf{X}","page":"Maths","title":"The Interior Product with a vector field iota_mathbfX","text":"Let mathbfX be a vector field. Then :\n\niota_mathbfX  Omega^k (M) mapsto Omega^k-1 (M)\n\nWe have iota_mathbfX (alpha)= alpha (mathbfX), and iota_mathbfX ( alpha wedge beta) = ( iota_mathbfX  alpha) wedge  beta + (-1)^alpha  alpha wedge ( iota_mathbfX beta ) with alpha=k the degree of the k-form alpha.\n\nLet mathbfX=x_1 mathbfi + x_2 mathbfj, then (in 2D),\n\niota_mathbfX F^0 = 0\n\niota_mathbfX U^1 = iota_mathbfX(u_1 mathrmd x+u_2 mathrmd y)=u_1 iota_mathbfX mathrmd x+u_2 iota_mathbfX mathrmd y = u_1x_1+u_2 x_2\n\nCorresponds to scalar product of two vector fields.\n\niota_mathbfX W^2 = iota_mathbfX(w mathrmd x wedge mathrmd y) = w( iota_mathbfX( mathrmd x) wedge mathrmd y - mathrmd x wedge iota_mathbfX( mathrmd  y)) = w(x_1 mathrmd  y-x_2 mathrmd  x)\n\nCorresponds to a kind of \"perpendicular product\" of a scalar field with a vector field.","category":"section"},{"location":"ref/maths/#The-Sharp-\\sharp","page":"Maths","title":"The Sharp sharp","text":"","category":"section"},{"location":"ref/maths/#The-Hodge-star-\\star","page":"Maths","title":"The Hodge star star","text":"","category":"section"},{"location":"ref/maths/#The-inverse-of-a-Laplacian","page":"Maths","title":"The inverse of a Laplacian","text":"","category":"section"},{"location":"ref/maths/#Others","page":"Maths","title":"Others","text":"","category":"section"},{"location":"ref/maths/#From-Forms-to-Arrays","page":"Maths","title":"From Forms to Arrays","text":"","category":"section"},{"location":"ref/maths/#SymPh.Maths","page":"Maths","title":"SymPh.Maths","text":"Maths\n\nA module containing symbolic representations of differential forms, and operations on them, and a way to convert them to array operations\n\n\n\n\n\n","category":"module"},{"location":"ref/maths/#SymPh.Maths.Form","page":"Maths","title":"SymPh.Maths.Form","text":"Form{D,P<:Primality}\n\nArguments\n\nD::Integer : degree (0/1/2... form)\nP::Primality : The primality of the form\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.Vect","page":"Maths","title":"SymPh.Maths.Vect","text":"Vect{P<:Primality}\n\nA vector field\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.FormVariable","page":"Maths","title":"SymPh.Maths.FormVariable","text":"FormVariable{D,P}(name::String) <: Form{D,P}\n\nA variable representing a named differential form\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.VectorVariable","page":"Maths","title":"SymPh.Maths.VectorVariable","text":"VectorVariable{P}(name::String) <: Vect{P}\n\nA variable representing a named vector field\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.Wedge","page":"Maths","title":"SymPh.Maths.Wedge","text":"Wedge{Dl + Dr,P}(name::String, left::Form{Dl,P}, right::Form{Dr,P}) <: Form{Dl + Dr, P}\n\nWedge product of two forms TODO Wedge between different primalities ?\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.ExteriorDerivative","page":"Maths","title":"SymPh.Maths.ExteriorDerivative","text":"ExteriorDerivative{D,P}(name::String, omega::Form{D-1,P}) <: Form{D,P}\n\nThe exterior derivative mathrmdomega\n\nTransforms a k-form into a k+1-form\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.Codifferential","page":"Maths","title":"SymPh.Maths.Codifferential","text":"Codifferential{D,P}(name::String, omega::Form{D+1,P}) <: Form{D,P}\n\nThe codifferential delta omega\n\nTransforms a k-form into a k-1-form\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.InteriorProduct","page":"Maths","title":"SymPh.Maths.InteriorProduct","text":"InteriorProduct{D, Pv, Pf}(name::String, X::Vect, omega::Form, interp = Nothing) <: Form{D, Pf}\n\nThe contraction of a k-form omega with a vector field mathbfX which gives us a k-1-form iota_mathbfXomega\n\nPossibility to specify interpolation function\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.Sharp","page":"Maths","title":"SymPh.Maths.Sharp","text":"Sharp{P}(name::String, form::Form{1, P}) <: Vect{P}\n\nCorresponds to an application of the metric\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.Hodge","page":"Maths","title":"SymPh.Maths.Hodge","text":"Hodge{D, P}(name::String, form::Form) <: Form{D, P}\n\nBrings a  k-form to a n-k form and goes from dual to primal and inversely\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.InverseLaplacian","page":"Maths","title":"SymPh.Maths.InverseLaplacian","text":"InverseLaplacian\n\nRepresents the solution to a Poisson problem\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.Addition","page":"Maths","title":"SymPh.Maths.Addition","text":"Addition{D,P}(name::String, left::Form{D,P}, right::Form{D,P}) <: Form{D,P}\n\nThe element-wise sum left + right.\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.Substraction","page":"Maths","title":"SymPh.Maths.Substraction","text":"Substraction{D,P}(name::String, left::Form{D,P}, right::Form{D,P}) <: Form{D,P}\n\nThe substraction left - right.\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.Negative","page":"Maths","title":"SymPh.Maths.Negative","text":"Negative{D,P}(name::String, form::Form{D,P}) <: Form{D,P}\n\nThe inverse of a form.\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.FuncCall","page":"Maths","title":"SymPh.Maths.FuncCall","text":"FuncCall{D, P}(name::String, func, args::Vector{Form}) <: Form{D,P}\n\nRepresents a call to func applied to the objects represented by args. Forces the computation of its arguments.\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.Division","page":"Maths","title":"SymPh.Maths.Division","text":"Division{D,P}(name::String, left::Form{D,P}, right::Form) <: Form{D,P}\n\nTODO What is that actually in terms of FORMS ? Simple division by a scalar field proxied by a 0-form ?\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.RealProdForm","page":"Maths","title":"SymPh.Maths.RealProdForm","text":"RealProdForm{D, P}(name::String, real::Real, form::Form) <: Form{D, P}\n\nreal time form\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.to_kernel","page":"Maths","title":"SymPh.Maths.to_kernel","text":"to_kernel(exprs...; explparams = ExplicitParam(), verbose=false, bcs = [])\n\nTakes one or multiple expressions and returns a kernel that computes them. The kernel has signature compute!(mesh::Mesh, state::State).\n\nKeyword Arguments\n\nexplparams::ExplicitParam : An object holding the parameters like which interpolation to use, etc... (see ExplicitParam)\nverbose::Bool : Wether or not to print the functions being generated, the dependency tree, etc...\nbcs : A list of objects representing our boundary conditions (WIP)\n\n\n\n\n\n","category":"function"},{"location":"ref/maths/#SymPh.Maths.explicit","page":"Maths","title":"SymPh.Maths.explicit","text":"explicit(expr::Expression, param = ExplicitParam())\n\nReturns a SymPh.Arrays Expression representing the operation expr on an array, pulling numerical methods from param\n\n\n\n\n\n","category":"function"},{"location":"ref/maths/#SymPh.Maths.ExplicitParam","page":"Maths","title":"SymPh.Maths.ExplicitParam","text":"ExplicitParam(;interp = Arrays.upwind, fvtofd = Arrays.fvtofd2, fdtofv = Arrays.fdtofv2)\n\nThe parameters used when necessary to choose numerical methods\n\n\n\n\n\n","category":"type"},{"location":"ref/misc/#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"ref/misc/#Model","page":"Miscellaneous","title":"Model","text":"","category":"section"},{"location":"ref/misc/#Time-integrators","page":"Miscellaneous","title":"Time integrators","text":"","category":"section"},{"location":"ref/misc/#Other","page":"Miscellaneous","title":"Other","text":"","category":"section"},{"location":"ref/misc/#SymPh.State","page":"Miscellaneous","title":"SymPh.State","text":"State(mesh)\n\nInitializes a State object that holds a list of arrays corresponding to the characteristics of mesh. Whenever trying to access a field, the state checks if the object is in its fields, in which case it returns it, and otherwise it allocates it and then returns it.\n\n\n\n\n\n","category":"type"},{"location":"ref/misc/#SymPh.reset_state","page":"Miscellaneous","title":"SymPh.reset_state","text":"reset_state(state::State)\n\nDeletes all the fields in state\n\n\n\n\n\n","category":"function"},{"location":"ref/misc/#SymPh.Model","page":"Miscellaneous","title":"SymPh.Model","text":"Model(rhs!, mesh, state, prognostics; integratorstep! = rk3step!, cfl = 0.6, dtmax = 1, Umax = nothing)\n\nRepresents an equation along with a mesh, its saved state and an integrator\n\n\n\n\n\n","category":"type"},{"location":"ref/misc/#SymPh.step!","page":"Miscellaneous","title":"SymPh.step!","text":"step!(model::Model; n=1, tend=-1)\n\nPerforms n integration steps of the model, and stops at tend if it is a strictly positive value\n\n\n\n\n\n","category":"function"},{"location":"ref/misc/#SymPh.run!","page":"Miscellaneous","title":"SymPh.run!","text":"run!(model; ...)\n\nTODO document\n\n\n\n\n\n","category":"function"},{"location":"ref/misc/#SymPh.profile_model!","page":"Miscellaneous","title":"SymPh.profile_model!","text":"profile_model!(model)\n\nRuns PProf to profile model\n\n\n\n\n\n","category":"function"},{"location":"ref/misc/#SymPh.euler_forwardstep!","page":"Miscellaneous","title":"SymPh.euler_forwardstep!","text":"euler_forwardstep!(dt, mesh, state, progs)\n\nArguments\n\ndt : time increment\nmesh : Mesh object\nstate : State object\nprogs : Name of prognostic variables\n\n\n\n\n\n","category":"function"},{"location":"ref/misc/#SymPh.rk3step!","page":"Miscellaneous","title":"SymPh.rk3step!","text":"rk3step!(dt, mesh, state, progs)\n\nArguments\n\ndt : time increment\nmesh : Mesh object\nstate : State object\nprogs : Name of prognostic variables\n\n\n\n\n\n","category":"function"},{"location":"ref/misc/#SymPh.rk4step!","page":"Miscellaneous","title":"SymPh.rk4step!","text":"rk4step!(dt, mesh, state, progs)\n\nArguments\n\ndt : time increment\nmesh : Mesh object\nstate : State object\nprogs : Name of prognostic variables\n\n\n\n\n\n","category":"function"},{"location":"ref/misc/#SymPh.@Let","page":"Miscellaneous","title":"SymPh.@Let","text":"@Let name = foo\n\nEvaluates the expression foo and sets its name to name, then assigns a local variable named appropriately\n\n\n\n\n\n","category":"macro"},{"location":"ref/misc/#SymPh.plotform","page":"Miscellaneous","title":"SymPh.plotform","text":"plotform(form, mesh, state)\n\nPlots form using the metric from mesh and the data from state\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"SymPh is a module","category":"section"},{"location":"man/equation/#Defining-our-equation","page":"Building an equation","title":"Defining our equation","text":"","category":"section"},{"location":"man/equation/#The-maths","page":"Building an equation","title":"The maths","text":"We will us as an example the stream function-vorticity formulation of the Euler equations with the vorticity omega as our prognostic variable. \n\nThis gives us \n\npartial_t omega = mathcalL_U omega = mathrmd(iota_U omega)\n\nwith \n\nbegincases\n    nabla^2 omega^2 = Psi^2 \n    u^1 = delta Psi \n    U = u^sharp\nendcases","category":"section"},{"location":"man/equation/#Representing-it","page":"Building an equation","title":"Representing it","text":"We use the @Let macro to avoid having to specify the name of each object we define. It will use the variable name as the object name.\n\nWe start by defining our prognostic variable :\n\n@Let omega = FormVariable{2, Dual}()\n\nThen we define the rest of the variables in relation to already defined variables :\n\n@Let psi = InverseLaplacian(omega)\n@Let u = Codifferential(psi)\n@Let U = Sharp(u)\n\n#Time derivative\n@Let dtomega = - ExteriorDerivative(InteriorProduct(U, omega)) #dtω = L(U,ω)\n\nFor now (if we want to use the time integrator from SymPh) the time derivative of prognostics variables must have the same name as the variable with dt at the beginning.","category":"section"},{"location":"man/equation/#Specifying-the-numerical-methods","page":"Building an equation","title":"Specifying the numerical methods","text":"We then build an ExplicitParam object, specifying for example the interpolation method used for the interior product.\n\nexplparams = ExplicitParam(; interp = Arrays.weno)","category":"section"},{"location":"man/equation/#Building-the-kernel-function","page":"Building an equation","title":"Building the kernel function","text":"We can now use those objects to finally generate the function that will perform our computations.\n\neuler_rhs! = to_kernel(dtomega; save = [\"u_i\", \"u_j\", \"ι_U_omega_i\", \"ι_U_omega_j\"], explparams = explparams)\n\nWe have to pass the objects that we want to be computed, for example in the case of a time integration, our time derivative, as well as a list of intermediary values that we want saved and our numerical methods.\n\n## Building the mesh\n\nWe then define the parameters of a mesh, notably its size and a mask of its fluid cells\n\nni = 100\nnj = 100\nnh = 3\n\nmsk = zeros(ni, nj)\nmsk[nh+1:ni-nh, nh+1:nj-nh] .= 1\n\nLx, Ly = (1,1)\n\nWe also have to choose a loop manager to run the program\n\nscalar = PlainCPU()\nsimd = VectorizedCPU(16)\nthreads = MultiThread(scalar)\n\nAnd we can finally build our mesh object\n\nmesh = Arrays.Mesh(ni, nj, nh, thsimd, msk, Lx, Ly)","category":"section"},{"location":"man/equation/#Defining-the-state-and-initial-conditions","page":"Building an equation","title":"Defining the state and initial conditions","text":"We initialize a State object, that will automatically allocate the arrays we ask it to give us, if they are not already initialized\n\nstate = State(mesh)\n\nand we fill our omega with an initial condition, for example a vortex merging experiment :\n\ngaussian(x,y,x0,y0,sigma) = exp(-((x-x0)^2 + (y-y0)^2)/(2*sigma^2))\ndipole(x,y,x0,y0,d,sigma) = gaussian(x, y, x0+d/2, y0, sigma) + gaussian(x, y, x0-d/2, y0, sigma)\n\nomega = state.omega\nfor i in nh+1:nx-nh, j in nh+1:ny-nh\n\tx = mesh.xc[i,j]\n\ty = mesh.yc[i,j]\n\tomega[i,j] = tripole(x, y, 0.5,0.5,0.3,0.05) * mesh.msk2d[i,j]\nend\n\nWe can now finally create the integration model that will hold all of this, by also specifying our prognostic variable and an integrator.\n\nmodel = Model(euler_rhs!, mesh, state, [\"omega\"]; cfl = 100., dtmax = 5., integratorstep! = rk3step!)","category":"section"},{"location":"man/equation/#Running-the-simulation","page":"Building an equation","title":"Running the simulation","text":"We can now run our model for a certain time, and choose which variables should be written to disk.\n\nrun!(model; save_every = 5, profiling = false, tend = 10000, maxite = 100, writevars = (:u_i, :u_j, :omega, :psi))","category":"section"}]
}

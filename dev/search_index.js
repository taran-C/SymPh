var documenterSearchIndex = {"docs":
[{"location":"ref/arrays/#Arrays","page":"Arrays","title":"Arrays","text":"","category":"section"},{"location":"ref/arrays/#SymPh.Arrays","page":"Arrays","title":"SymPh.Arrays","text":"Arrays\n\nA module containing symbolic representations of arrays, and operations on them, and a way to convert them to computational kernels\n\n\n\n\n\n","category":"module"},{"location":"ref/arrays/#Objects-and-Variables","page":"Arrays","title":"Objects and Variables","text":"","category":"section"},{"location":"ref/arrays/#Abstract-types","page":"Arrays","title":"Abstract types","text":"","category":"section"},{"location":"ref/arrays/#SymPh.Arrays.Expression","page":"Arrays","title":"SymPh.Arrays.Expression","text":"Expression\n\nGeneric Expression\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Atom","page":"Arrays","title":"SymPh.Arrays.Atom","text":"Atom <: Expression\n\nAn atom is a singular element holding a value (Variable or not)\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Literal","page":"Arrays","title":"SymPh.Arrays.Literal","text":"Literal <: Atom\n\nLiteral constant value\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Variable","page":"Arrays","title":"SymPh.Arrays.Variable","text":"Variable <: Atom\n\nAny variable value\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#Concrete-types","page":"Arrays","title":"Concrete types","text":"","category":"section"},{"location":"ref/arrays/#SymPh.Arrays.RealValue","page":"Arrays","title":"SymPh.Arrays.RealValue","text":"RealValue(name::String, val::Real) <: Literal\n\nA constant real value\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.ScalarVariable","page":"Arrays","title":"SymPh.Arrays.ScalarVariable","text":"ScalarVariable(name::String) <: Variable\n\nA variable holding a single scalar value\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.ArrayVariable","page":"Arrays","title":"SymPh.Arrays.ArrayVariable","text":"ArrayVariable(name::String, depi::Integer, depj::Integer) <: Variable\n\nArray object representing a variable name and a relative position\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#Operations-on-arrays","page":"Arrays","title":"Operations on arrays","text":"","category":"section"},{"location":"ref/arrays/#SymPh.Arrays.Operator","page":"Arrays","title":"SymPh.Arrays.Operator","text":"Operator <: Expression\n\nGeneric operation on an expression\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.FuncCall","page":"Arrays","title":"SymPh.Arrays.FuncCall","text":"FuncCall(name::String, func, args::Vector{Expression}, depi::Integer, depj::Integer) <: Operator\n\nForces computation of its arguments, then calls a function on them For now the function must have signature f(out, args...) where out will be replaced by the name assigned to the operator\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.UnaryOperator","page":"Arrays","title":"SymPh.Arrays.UnaryOperator","text":"UnaryOperator\n\nAny operator of a single argument\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Negative","page":"Arrays","title":"SymPh.Arrays.Negative","text":"Negative\n\nRepresents the negation of an expression\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.AbsoluteValue","page":"Arrays","title":"SymPh.Arrays.AbsoluteValue","text":"AbsoluteValue\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.BinaryOperator","page":"Arrays","title":"SymPh.Arrays.BinaryOperator","text":"BinaryOperator\n\nAny operator on two expressions\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Addition","page":"Arrays","title":"SymPh.Arrays.Addition","text":"Addition\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Substraction","page":"Arrays","title":"SymPh.Arrays.Substraction","text":"Substraction\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Multiplication","page":"Arrays","title":"SymPh.Arrays.Multiplication","text":"Multiplication\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Division","page":"Arrays","title":"SymPh.Arrays.Division","text":"Division\n\nTODO error handling\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Exponentiation","page":"Arrays","title":"SymPh.Arrays.Exponentiation","text":"Exponentiation\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.BooleanExpression","page":"Arrays","title":"SymPh.Arrays.BooleanExpression","text":"BooleanExpression\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.UnaryBooleanOperator","page":"Arrays","title":"SymPh.Arrays.UnaryBooleanOperator","text":"UnaryBooleanOperator\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.BinaryBooleanOperator","page":"Arrays","title":"SymPh.Arrays.BinaryBooleanOperator","text":"BinaryBooleanOperator\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.TernaryOperator","page":"Arrays","title":"SymPh.Arrays.TernaryOperator","text":"TernaryOperator\n\nSymbolic representation of a ? b : c\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.GreaterThan","page":"Arrays","title":"SymPh.Arrays.GreaterThan","text":"GreaterThan\n\ntests if left > right\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#Meshes","page":"Arrays","title":"Meshes","text":"","category":"section"},{"location":"ref/arrays/#SymPh.Arrays.Mesh","page":"Arrays","title":"SymPh.Arrays.Mesh","text":"Mesh(ni, nj, nh, mgr, msk, xc, yc, xv, yv; iperio=false, jperio=false)\n\nTODO document\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.CartesianMesh","page":"Arrays","title":"SymPh.Arrays.CartesianMesh","text":"CartesianMesh(ni, nj, nh, mgr, Lx = 1, Ly = 1; xperio=false, yperio=false)\n\nA rectangular mesh of extent Lx, Ly\n\n\n\n\n\n","category":"function"},{"location":"ref/arrays/#SymPh.Arrays.PolarMesh","page":"Arrays","title":"SymPh.Arrays.PolarMesh","text":"PolarMesh(ni, nj, nh, mgr, msk, rin = 0.5, rout = 1.5)\n\nAn annulus mesh with inner radius rin and outer radius rout\n\nThe i/x direction is the radial, j/y orthoradial\n\n\n\n\n\n","category":"function"},{"location":"ref/arrays/#Interpolations","page":"Arrays","title":"Interpolations","text":"","category":"section"},{"location":"ref/arrays/#SymPh.Arrays.upwind","page":"Arrays","title":"SymPh.Arrays.upwind","text":"upwind(U::Expression, a::Expression, o::Expression, lr::String, dir::String)\n\nFive point upwind interpolation\n\nArguments\n\nU : The transportant velocity\na : The object to upwind\no : The order of interpolation at that point\nlr : If lr==\"left\", compute a[i-0.5], else a[i+0.5]\ndir : along i or j\n\n\n\n\n\n","category":"function"},{"location":"ref/arrays/#SymPh.Arrays.avg2pt","page":"Arrays","title":"SymPh.Arrays.avg2pt","text":"avg2pt(U::Expression, a::Expression, o::Expression, lr::String, dir::String)\n\nTwo point average interpolation\n\nArguments\n\nU : The transportant velocity, unused\na : The object to interpolate\no : The order of interpolation at that point, unused\nlr : If lr==\"left\", compute a[i-0.5], else a[i+0.5]\ndir : along i or j\n\n\n\n\n\n","category":"function"},{"location":"ref/arrays/#SymPh.Arrays.weno","page":"Arrays","title":"SymPh.Arrays.weno","text":"weno(U::Expression, a::Expression, o::Expression, lr::String, dir::String)\n\nWeno interpolation of fifth order\n\nArguments\n\nU : The transportant velocity\na : The object to upwind\no : The order of interpolation at that point\nlr : If lr==\"left\", compute a[i-0.5], else a[i+0.5]\ndir : along i or j\n\n\n\n\n\n","category":"function"},{"location":"ref/arrays/#Finite-volumes-and-finite-differences","page":"Arrays","title":"Finite volumes and finite differences","text":"","category":"section"},{"location":"ref/arrays/#SymPh.Arrays.fvtofd2","page":"Arrays","title":"SymPh.Arrays.fvtofd2","text":"fvtofd2(q, msk, dir)\n\nA second order function to take a finite volume quantity q to finite difference in the direction dir, using msk to detect borders\n\n\n\n\n\n","category":"function"},{"location":"ref/arrays/#SymPh.Arrays.fvtofd4","page":"Arrays","title":"SymPh.Arrays.fvtofd4","text":"fvtofd4(q, msk, dir)\n\nA fourth order function to take a finite volume quantity q to finite difference in the direction dir, using msk to detect borders\n\n\n\n\n\n","category":"function"},{"location":"ref/arrays/#SymPh.Arrays.fdtofv2","page":"Arrays","title":"SymPh.Arrays.fdtofv2","text":"fdtofv2(q, msk, dir)\n\nA second order function to take a finite difference quantity q to finite volume in the direction dir, using msk to detect borders\n\n\n\n\n\n","category":"function"},{"location":"ref/arrays/#SymPh.Arrays.fdtofv4","page":"Arrays","title":"SymPh.Arrays.fdtofv4","text":"fdtofv4(q, msk, dir)\n\nA fourth order function to take a finite difference quantity q to finite volume in the direction dir, using msk to detect borders\n\n\n\n\n\n","category":"function"},{"location":"ref/arrays/#From-arrays-to-kernels","page":"Arrays","title":"From arrays to kernels","text":"","category":"section"},{"location":"ref/arrays/#SymPh.Arrays.DepNode","page":"Arrays","title":"SymPh.Arrays.DepNode","text":"DepNode(name::String, expr::Union{Nothing, Expression})\n\nA node of a dependency tree of expressions made of expressions\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Block","page":"Arrays","title":"SymPh.Arrays.Block","text":"Block\n\nAny operation or block of operations that can be done at once\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.LoopBlock","page":"Arrays","title":"SymPh.Arrays.LoopBlock","text":"LoopBlock\n\nA block of operations to be computed in a loop on our domain\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.CallBlock","page":"Arrays","title":"SymPh.Arrays.CallBlock","text":"CallBlock\n\nA block representing a single function call\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.Sequence","page":"Arrays","title":"SymPh.Arrays.Sequence","text":"Sequence\n\nA sequence of blocks of operations\n\n\n\n\n\n","category":"type"},{"location":"ref/arrays/#SymPh.Arrays.to_kernel","page":"Arrays","title":"SymPh.Arrays.to_kernel","text":"to_kernel(seq::Sequence, fill; verbose = false)\n\nConverts seq into a computing kernel, fill is the list of names of value that need their halo filled.\n\n\n\n\n\n","category":"function"},{"location":"ref/maths/#Maths","page":"Maths","title":"Maths","text":"","category":"section"},{"location":"ref/maths/#SymPh.Maths","page":"Maths","title":"SymPh.Maths","text":"Maths\n\nA module containing symbolic representations of differential forms, and operations on them, and a way to convert them to array operations\n\n\n\n\n\n","category":"module"},{"location":"ref/maths/#Abstract-Objects","page":"Maths","title":"Abstract Objects","text":"","category":"section"},{"location":"ref/maths/","page":"Maths","title":"Maths","text":"These are abstract object representing differential forms and vectors","category":"page"},{"location":"ref/maths/#SymPh.Maths.Form","page":"Maths","title":"SymPh.Maths.Form","text":"Form{D,P<:Primality}\n\nArguments\n\nD::Integer : degree (0/1/2... form)\nP::Primality : The primality of the form\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.Vect","page":"Maths","title":"SymPh.Maths.Vect","text":"Vect{P<:Primality}\n\nA vector field\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#Variables","page":"Maths","title":"Variables","text":"","category":"section"},{"location":"ref/maths/","page":"Maths","title":"Maths","text":"The variables upon which we act with our operators. Typically our prognostic variables will be defined like this since they are not defined as an operation on something.","category":"page"},{"location":"ref/maths/#SymPh.Maths.FormVariable","page":"Maths","title":"SymPh.Maths.FormVariable","text":"FormVariable{D,P}(name::String) <: Form{D,P}\n\nA variable representing a named differential form\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.VectorVariable","page":"Maths","title":"SymPh.Maths.VectorVariable","text":"VectorVariable{P}(name::String) <: Vect{P}\n\nA variable representing a named vector field\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#Operators","page":"Maths","title":"Operators","text":"","category":"section"},{"location":"ref/maths/","page":"Maths","title":"Maths","text":"These are the operators acting on our variables. Their type is the type of the result of the operation.","category":"page"},{"location":"ref/maths/#The-Wedge-product-\\wedge","page":"Maths","title":"The Wedge product wedge","text":"","category":"section"},{"location":"ref/maths/#SymPh.Maths.Wedge","page":"Maths","title":"SymPh.Maths.Wedge","text":"Wedge{Dl + Dr,P}(name::String, left::Form{Dl,P}, right::Form{Dr,P}) <: Form{Dl + Dr, P}\n\nWedge product of two forms TODO Wedge between different primalities ?\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#The-Exterior-Derivative-\\mathrm{d}","page":"Maths","title":"The Exterior Derivative mathrmd","text":"","category":"section"},{"location":"ref/maths/#SymPh.Maths.ExteriorDerivative","page":"Maths","title":"SymPh.Maths.ExteriorDerivative","text":"ExteriorDerivative{D,P}(name::String, omega::Form{D-1,P}) <: Form{D,P}\n\nThe exterior derivative mathrmdomega\n\nTransforms a k-form into a k+1-form\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/","page":"Maths","title":"Maths","text":"The exterior derivative mathrmdomega of a k-form omega is a k+1-form.","category":"page"},{"location":"ref/maths/","page":"Maths","title":"Maths","text":"In 2D, ","category":"page"},{"location":"ref/maths/","page":"Maths","title":"Maths","text":"mathrmdF^0 = partial_x f mathrmd x+partial_y f mathrmd y","category":"page"},{"location":"ref/maths/","page":"Maths","title":"Maths","text":"Corresponds to the gradient operation on a scalar field.","category":"page"},{"location":"ref/maths/","page":"Maths","title":"Maths","text":"mathrmdU^1 = (partial_x u_2-partial_y u_1) mathrmd x wedge mathrmd y","category":"page"},{"location":"ref/maths/","page":"Maths","title":"Maths","text":"Corresponds to the curl of a vector field.","category":"page"},{"location":"ref/maths/","page":"Maths","title":"Maths","text":"mathrmd W^2 = 0","category":"page"},{"location":"ref/maths/#The-Codifferential-\\delta","page":"Maths","title":"The Codifferential delta","text":"","category":"section"},{"location":"ref/maths/#SymPh.Maths.Codifferential","page":"Maths","title":"SymPh.Maths.Codifferential","text":"Codifferential{D,P}(name::String, omega::Form{D+1,P}) <: Form{D,P}\n\nThe codifferential delta omega\n\nTransforms a k-form into a k-1-form\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#The-Interior-Product-with-a-vector-field-\\iota_\\mathbf{X}","page":"Maths","title":"The Interior Product with a vector field iota_mathbfX","text":"","category":"section"},{"location":"ref/maths/#SymPh.Maths.InteriorProduct","page":"Maths","title":"SymPh.Maths.InteriorProduct","text":"InteriorProduct{D, Pv, Pf}(name::String, X::Vect, omega::Form, interp = Nothing) <: Form{D, Pf}\n\nThe contraction of a k-form omega with a vector field mathbfX which gives us a k-1-form iota_mathbfXomega\n\nPossibility to specify interpolation function\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/","page":"Maths","title":"Maths","text":"Let mathbfX be a vector field. Then :","category":"page"},{"location":"ref/maths/","page":"Maths","title":"Maths","text":"iota_mathbfX  Omega^k (M) mapsto Omega^k-1 (M)","category":"page"},{"location":"ref/maths/","page":"Maths","title":"Maths","text":"We have iota_mathbfX (alpha)= alpha (mathbfX), and iota_mathbfX ( alpha wedge beta) = ( iota_mathbfX  alpha) wedge  beta + (-1)^alpha  alpha wedge ( iota_mathbfX beta ) with alpha=k the degree of the k-form alpha.","category":"page"},{"location":"ref/maths/","page":"Maths","title":"Maths","text":"Let mathbfX=x_1 mathbfi + x_2 mathbfj, then (in 2D),","category":"page"},{"location":"ref/maths/","page":"Maths","title":"Maths","text":"iota_mathbfX F^0 = 0","category":"page"},{"location":"ref/maths/","page":"Maths","title":"Maths","text":"iota_mathbfX U^1 = iota_mathbfX(u_1 mathrmd x+u_2 mathrmd y)=u_1 iota_mathbfX mathrmd x+u_2 iota_mathbfX mathrmd y = u_1x_1+u_2 x_2","category":"page"},{"location":"ref/maths/","page":"Maths","title":"Maths","text":"Corresponds to scalar product of two vector fields.","category":"page"},{"location":"ref/maths/","page":"Maths","title":"Maths","text":"iota_mathbfX W^2 = iota_mathbfX(w mathrmd x wedge mathrmd y) = w( iota_mathbfX( mathrmd x) wedge mathrmd y - mathrmd x wedge iota_mathbfX( mathrmd  y)) = w(x_1 mathrmd  y-x_2 mathrmd  x)","category":"page"},{"location":"ref/maths/","page":"Maths","title":"Maths","text":"Corresponds to a kind of \"perpendicular product\" of a scalar field with a vector field.","category":"page"},{"location":"ref/maths/#The-Sharp-\\sharp","page":"Maths","title":"The Sharp sharp","text":"","category":"section"},{"location":"ref/maths/#SymPh.Maths.Sharp","page":"Maths","title":"SymPh.Maths.Sharp","text":"Sharp{P}(name::String, form::Form{1, P}) <: Vect{P}\n\nCorresponds to an application of the metric\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#The-Hodge-star-\\star","page":"Maths","title":"The Hodge star star","text":"","category":"section"},{"location":"ref/maths/#SymPh.Maths.Hodge","page":"Maths","title":"SymPh.Maths.Hodge","text":"Hodge{D, P}(name::String, form::Form) <: Form{D, P}\n\nBrings a  k-form to a n-k form and goes from dual to primal and inversely\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#The-inverse-of-a-Laplacian","page":"Maths","title":"The inverse of a Laplacian","text":"","category":"section"},{"location":"ref/maths/#SymPh.Maths.InverseLaplacian","page":"Maths","title":"SymPh.Maths.InverseLaplacian","text":"InverseLaplacian\n\nRepresents the solution to a Poisson problem\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#Others","page":"Maths","title":"Others","text":"","category":"section"},{"location":"ref/maths/#SymPh.Maths.Addition","page":"Maths","title":"SymPh.Maths.Addition","text":"Addition{D,P}(name::String, left::Form{D,P}, right::Form{D,P}) <: Form{D,P}\n\nThe element-wise sum left + right.\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.Substraction","page":"Maths","title":"SymPh.Maths.Substraction","text":"Substraction{D,P}(name::String, left::Form{D,P}, right::Form{D,P}) <: Form{D,P}\n\nThe substraction left - right.\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.Negative","page":"Maths","title":"SymPh.Maths.Negative","text":"Negative{D,P}(name::String, form::Form{D,P}) <: Form{D,P}\n\nThe inverse of a form.\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.FuncCall","page":"Maths","title":"SymPh.Maths.FuncCall","text":"FuncCall{D, P}(name::String, func, args::Vector{Form}) <: Form{D,P}\n\nRepresents a call to func applied to the objects represented by args. Forces the computation of its arguments.\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.Division","page":"Maths","title":"SymPh.Maths.Division","text":"Division{D,P}(name::String, left::Form{D,P}, right::Form) <: Form{D,P}\n\nTODO What is that actually in terms of FORMS ? Simple division by a scalar field proxied by a 0-form ?\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#SymPh.Maths.RealProdForm","page":"Maths","title":"SymPh.Maths.RealProdForm","text":"RealProdForm{D, P}(name::String, real::Real, form::Form) <: Form{D, P}\n\nreal time form\n\n\n\n\n\n","category":"type"},{"location":"ref/maths/#From-Forms-to-Arrays","page":"Maths","title":"From Forms to Arrays","text":"","category":"section"},{"location":"ref/maths/#SymPh.Maths.to_kernel","page":"Maths","title":"SymPh.Maths.to_kernel","text":"to_kernel(exprs...; save = [], explparams = ExplicitParam(), verbose=false, bcs = [])\n\nTakes one or multiple expressions and returns a kernel that computes them. The kernel has signature compute!(mesh::Mesh, state::State).\n\nKeyword Arguments\n\nsave : A list of the intermediary value to save (not inline) into the state\nexplparams::ExplicitParam : An object holding the parameters like which interpolation to use, etc... (see ExplicitParam)\nverbose::Bool : Wether or not to print the functions being generated, the dependency tree, etc...\nbcs : A list of objects representing our boundary conditions (WIP)\n\n\n\n\n\n","category":"function"},{"location":"ref/maths/#SymPh.Maths.explicit","page":"Maths","title":"SymPh.Maths.explicit","text":"explicit(expr::Expression, param = ExplicitParam())\n\nReturns a SymPh.Arrays Expression representing the operation expr on an array, pulling numerical methods from param\n\n\n\n\n\n","category":"function"},{"location":"ref/maths/#SymPh.Maths.ExplicitParam","page":"Maths","title":"SymPh.Maths.ExplicitParam","text":"ExplicitParam(;interp = Arrays.upwind, fvtofd = Arrays.fvtofd2, fdtofv = Arrays.fdtofv2)\n\nThe parameters used when necessary to choose numerical methods\n\n\n\n\n\n","category":"type"},{"location":"ref/misc/#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"ref/misc/#SymPh.State","page":"Miscellaneous","title":"SymPh.State","text":"State(mesh)\n\nInitializes a State object that holds a list of arrays corresponding to the characteristics of mesh. Whenever trying to access a field, the state checks if the object is in its fields, in which case it returns it, and otherwise it allocates it and then returns it.\n\n\n\n\n\n","category":"type"},{"location":"ref/misc/#SymPh.reset_state","page":"Miscellaneous","title":"SymPh.reset_state","text":"reset_state(state::State)\n\nDeletes all the fields in state\n\n\n\n\n\n","category":"function"},{"location":"ref/misc/#Model","page":"Miscellaneous","title":"Model","text":"","category":"section"},{"location":"ref/misc/#SymPh.Model","page":"Miscellaneous","title":"SymPh.Model","text":"Model(rhs!, mesh, state, prognostics; integratorstep! = rk3step!, cfl = 0.6, dtmax = 1, Umax = nothing)\n\nRepresents an equation along with a mesh, its saved state and an integrator\n\n\n\n\n\n","category":"type"},{"location":"ref/misc/#SymPh.step!","page":"Miscellaneous","title":"SymPh.step!","text":"step!(model::Model; n=1, tend=-1)\n\nPerforms n integration steps of the model, and stops at tend if it is a strictly positive value\n\n\n\n\n\n","category":"function"},{"location":"ref/misc/#SymPh.run!","page":"Miscellaneous","title":"SymPh.run!","text":"run!(model; ...)\n\nTODO document\n\n\n\n\n\n","category":"function"},{"location":"ref/misc/#SymPh.profile_model!","page":"Miscellaneous","title":"SymPh.profile_model!","text":"profile_model!(model)\n\nRuns PProf to profile model\n\n\n\n\n\n","category":"function"},{"location":"ref/misc/#Time-integrators","page":"Miscellaneous","title":"Time integrators","text":"","category":"section"},{"location":"ref/misc/#SymPh.euler_forwardstep!","page":"Miscellaneous","title":"SymPh.euler_forwardstep!","text":"euler_forwardstep!(dt, mesh, state, progs)\n\nArguments\n\ndt : time increment\nmesh : Mesh object\nstate : State object\nprogs : Name of prognostic variables\n\n\n\n\n\n","category":"function"},{"location":"ref/misc/#SymPh.rk3step!","page":"Miscellaneous","title":"SymPh.rk3step!","text":"rk3step!(dt, mesh, state, progs)\n\nArguments\n\ndt : time increment\nmesh : Mesh object\nstate : State object\nprogs : Name of prognostic variables\n\n\n\n\n\n","category":"function"},{"location":"ref/misc/#SymPh.rk4step!","page":"Miscellaneous","title":"SymPh.rk4step!","text":"rk4step!(dt, mesh, state, progs)\n\nArguments\n\ndt : time increment\nmesh : Mesh object\nstate : State object\nprogs : Name of prognostic variables\n\n\n\n\n\n","category":"function"},{"location":"ref/misc/#Other","page":"Miscellaneous","title":"Other","text":"","category":"section"},{"location":"ref/misc/#SymPh.@Let","page":"Miscellaneous","title":"SymPh.@Let","text":"@Let name = foo\n\nEvaluates the expression foo and sets its name to name, then assigns a local variable named appropriately\n\n\n\n\n\n","category":"macro"},{"location":"ref/misc/#SymPh.plotform","page":"Miscellaneous","title":"SymPh.plotform","text":"plotform(form, mesh, state)\n\nPlots form using the metric from mesh and the data from state\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"SymPh is a module","category":"page"},{"location":"man/equation/#Defining-our-equation","page":"Building an equation","title":"Defining our equation","text":"","category":"section"},{"location":"man/equation/#The-maths","page":"Building an equation","title":"The maths","text":"","category":"section"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We will us as an example the stream function-vorticity formulation of the Euler equations with the vorticity omega as our prognostic variable. ","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"This gives us ","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"partial_t omega = mathcalL_U omega = mathrmd(iota_U omega)","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"with ","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"begincases\n    nabla^2 omega^2 = Psi^2 \n    u^1 = delta Psi \n    U = u^sharp\nendcases","category":"page"},{"location":"man/equation/#Representing-it","page":"Building an equation","title":"Representing it","text":"","category":"section"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We use the @Let macro to avoid having to specify the name of each object we define. It will use the variable name as the object name.","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We start by defining our prognostic variable :","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"@Let omega = FormVariable{2, Dual}()","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"Then we define the rest of the variables in relation to already defined variables :","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"@Let psi = InverseLaplacian(omega)\n@Let u = Codifferential(psi)\n@Let U = Sharp(u)\n\n#Time derivative\n@Let dtomega = - ExteriorDerivative(InteriorProduct(U, omega)) #dtω = L(U,ω)","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"For now (if we want to use the time integrator from SymPh) the time derivative of prognostics variables must have the same name as the variable with dt at the beginning.","category":"page"},{"location":"man/equation/#Specifying-the-numerical-methods","page":"Building an equation","title":"Specifying the numerical methods","text":"","category":"section"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We then build an ExplicitParam object, specifying for example the interpolation method used for the interior product.","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"explparams = ExplicitParam(; interp = Arrays.weno)","category":"page"},{"location":"man/equation/#Building-the-kernel-function","page":"Building an equation","title":"Building the kernel function","text":"","category":"section"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We can now use those objects to finally generate the function that will perform our computations.","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"euler_rhs! = to_kernel(dtomega; save = [\"u_i\", \"u_j\", \"ι_U_omega_i\", \"ι_U_omega_j\"], explparams = explparams)","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We have to pass the objects that we want to be computed, for example in the case of a time integration, our time derivative, as well as a list of intermediary values that we want saved and our numerical methods.","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"## Building the mesh","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We then define the parameters of a mesh, notably its size and a mask of its fluid cells","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"ni = 100\nnj = 100\nnh = 3\n\nmsk = zeros(ni, nj)\nmsk[nh+1:ni-nh, nh+1:nj-nh] .= 1\n\nLx, Ly = (1,1)","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We also have to choose a loop manager to run the program","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"scalar = PlainCPU()\nsimd = VectorizedCPU(16)\nthreads = MultiThread(scalar)","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"And we can finally build our mesh object","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"mesh = Arrays.Mesh(ni, nj, nh, thsimd, msk, Lx, Ly)","category":"page"},{"location":"man/equation/#Defining-the-state-and-initial-conditions","page":"Building an equation","title":"Defining the state and initial conditions","text":"","category":"section"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We initialize a State object, that will automatically allocate the arrays we ask it to give us, if they are not already initialized","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"state = State(mesh)","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"and we fill our omega with an initial condition, for example a vortex merging experiment :","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"gaussian(x,y,x0,y0,sigma) = exp(-((x-x0)^2 + (y-y0)^2)/(2*sigma^2))\ndipole(x,y,x0,y0,d,sigma) = gaussian(x, y, x0+d/2, y0, sigma) + gaussian(x, y, x0-d/2, y0, sigma)\n\nomega = state.omega\nfor i in nh+1:nx-nh, j in nh+1:ny-nh\n\tx = mesh.xc[i,j]\n\ty = mesh.yc[i,j]\n\tomega[i,j] = tripole(x, y, 0.5,0.5,0.3,0.05) * mesh.msk2d[i,j]\nend","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We can now finally create the integration model that will hold all of this, by also specifying our prognostic variable and an integrator.","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"model = Model(euler_rhs!, mesh, state, [\"omega\"]; cfl = 100., dtmax = 5., integratorstep! = rk3step!)","category":"page"},{"location":"man/equation/#Running-the-simulation","page":"Building an equation","title":"Running the simulation","text":"","category":"section"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"We can now run our model for a certain time, and choose which variables should be written to disk.","category":"page"},{"location":"man/equation/","page":"Building an equation","title":"Building an equation","text":"run!(model; save_every = 5, profiling = false, tend = 10000, maxite = 100, writevars = (:u_i, :u_j, :omega, :psi))","category":"page"}]
}
